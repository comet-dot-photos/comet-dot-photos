
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NAC4I.1 Image Download Speed Test</title>
  <style>
    body { font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin: 1.5rem; }
    h1 { font-size: 1.4rem; margin-bottom: 0.25rem; }
    label, button { font-size: 0.95rem; }
    input[type="text"], input[type="number"] {
      width: 100%;
      max-width: 720px;
      padding: 0.35rem 0.5rem;
      margin-bottom: 0.75rem;
      box-sizing: border-box;
    }
    button { padding: 0.35rem 0.7rem; cursor: pointer; margin-right: 0.5rem; }
    #status { margin-top: 0.75rem; font-family: ui-monospace, Menlo, Consolas, monospace; white-space: pre-line; }
    .row { display: flex; gap: 0.75rem; max-width: 720px; flex-wrap: wrap; }
    .row > label { flex: 1 1 340px; }
    .hint { font-size: 0.85rem; color: #444; margin-top: -0.35rem; margin-bottom: 0.75rem; max-width: 720px; }
    .hostline { font-family: ui-monospace, Menlo, Consolas, monospace; margin: 0.2rem 0; }
    .hostline button { font-family: inherit; font-size: 0.9rem; padding: 0.15rem 0.45rem; margin-right: 0.5rem; }
    table { border-collapse: collapse; margin-top: 0.75rem; font-size: 0.8rem; max-width: 100%; overflow-x: auto; display: block; }
    th, td { border: 1px solid #ccc; padding: 0.2rem 0.4rem; text-align: right; }
    th:nth-child(2), td:nth-child(2) { text-align: left; max-width: 520px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  </style>
</head>

<body>
  <h1>NAC4I.1 Image Download Speed Test</h1>
  <p>
    Downloads N NAC4I.1 images sequentially and reports approximate throughput.
    Attempts to bypass caching via <code>cache: 'no-store'</code> and a cache-busting query string.
  </p>

  <label>
    Dataset JSON URL:
    <input id="datasetUrl" type="text" value="rosetta/NAC4I.1/imageMetadataNAC4I.1.json">
  </label>

  <label>
    NAC4I.1 image root (relative or absolute, ends with <code>/NAC4I.1/J80/</code>):
    <input id="imageRoot" type="text" value="/rosetta/NAC4I.1/J80/">
  </label>

  <div class="row">
    <label>
      Origin:
      <input id="origin" type="text" value="">
    </label>
    <label>
      Fastest Origin:
      <input id="fastestOrigin" type="text" value="" readonly>
    </label>
  </div>

  <div class="hint">
    Origin is like <code>https://comet.photos</code>. If image root is absolute (<code>https://…</code>),
    Origin is ignored and “Find Fastest” is skipped.
  </div>

  <div class="row" style="align-items: center;">
    <label>
      Number of images to race:
      <input id="raceCount" type="number" min="1" max="50" value="5">
    </label>
    <button id="findFastestBtn" style="margin-left: 0.75rem;">Find Fastest</button>
  </div>


  <label>
    Number of images to fetch:
    <input id="imageCount" type="number" min="1" max="1000" value="100">
  </label>

  <button id="runBtn">Run test</button>

  <div id="status"></div>
  <div id="hostResults"></div>
  <div id="results"></div>

  <script>
    const runBtn = document.getElementById('runBtn');
    const findFastestBtn = document.getElementById('findFastestBtn');
    const statusEl = document.getElementById('status');
    const hostResultsEl = document.getElementById('hostResults');
    const resultsEl = document.getElementById('results');

    const originEl = document.getElementById('origin');
    const fastestOriginEl = document.getElementById('fastestOrigin');
    const raceCountEl = document.getElementById('raceCount');

    originEl.value = normalizeOrigin(window.location.origin);

    runBtn.addEventListener('click', () => runTest().catch(fail));
    findFastestBtn.addEventListener('click', () => findFastest().catch(fail));

    function fail(err) {
      console.error(err);
      statusEl.textContent = 'Error: ' + (err?.message || String(err));
      runBtn.disabled = false;
      findFastestBtn.disabled = false;
    }

    function normalizeOrigin(o) {
      o = (o || '').trim();
      if (!o) return '';
      return o.replace(/\/+$/, '');
    }
    function normalizeRoot(r) {
      r = (r || '').trim();
      if (!r) return '';
      return r.endsWith('/') ? r : (r + '/');
    }
    function isAbsoluteHttpUrl(s) {
      return /^https?:\/\//i.test(s || '');
    }
    function joinOriginAndPath(origin, pathOrRel) {
      const o = normalizeOrigin(origin);
      const p = (pathOrRel || '').trim();
      if (!o) return p;
      if (p.startsWith('/')) return o + p;
      return o + '/' + p;
    }

    async function fetchDatasetJson(datasetUrl) {
      const r = await fetch(datasetUrl, { cache: 'no-store' });
      if (!r.ok) throw new Error(`Failed to fetch dataset: HTTP ${r.status}`);
      const dataset = await r.json();
      if (!Array.isArray(dataset) || dataset.length === 0) throw new Error('Dataset JSON is not a non-empty array.');
      return dataset;
    }

    function buildNac4iPath(imageRoot, entry) {
      const nm = entry.nm;
      if (!nm || typeof nm !== 'string' || nm.length < 7) throw new Error('Invalid nm in entry.');
      const yyyymm = nm.substring(1, 7);
      return imageRoot + yyyymm + '/' + nm + '.jpg';
    }

    // Cache the HOST LIST only (not results).
    let cachedHosts = null;
    async function fetchCdnHosts() {
      if (cachedHosts) return cachedHosts;
      const r = await fetch('https://comet.photos/cdn_hosts.json', { cache: 'no-store' });
      if (!r.ok) return null;
      const j = await r.json();
      if (!Array.isArray(j) || j.length === 0) return null;
      cachedHosts = j;
      return cachedHosts;
    }

    async function timedDownload(url, timeoutMs) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);
      const t0 = performance.now();
      try {
        const resp = await fetch(url, { cache: 'no-store', signal: ctrl.signal });
        if (!resp.ok) return { ok: false, ms: performance.now() - t0, bytes: 0, err: `HTTP ${resp.status}` };
        const buf = await resp.arrayBuffer();
        return { ok: true, ms: performance.now() - t0, bytes: buf.byteLength, err: '' };
      } catch (e) {
        return { ok: false, ms: performance.now() - t0, bytes: 0, err: e?.message || 'fetch error' };
      } finally {
        clearTimeout(t);
      }
    }

    function renderHostLines(rows) {
      hostResultsEl.innerHTML = '';
      rows.forEach(r => {
        const line = document.createElement('div');
        line.className = 'hostline';

        const btn = document.createElement('button');
        btn.textContent = 'Test';
        btn.disabled = !r.ok; // only enable if it worked
        btn.addEventListener('click', async () => {
          originEl.value = `https://${r.host}`;
          fastestOriginEl.value = '';
          await runTest();
        });

        const txt = document.createElement('span');
        const ms = Number.isFinite(r.ms) ? `${r.ms.toFixed(1)} ms` : '';
        const bytes = r.bytes ? `, ${r.bytes} bytes` : '';
        const status = r.ok ? 'OK' : `ERR (${r.err})`;
        txt.textContent = `${r.host}  —  ${status}${r.ok ? `  ${ms}${bytes}` : ''}`;

        line.appendChild(btn);
        line.appendChild(txt);
        hostResultsEl.appendChild(line);
      });
    }

    async function findFastest() {
      runBtn.disabled = true;
      findFastestBtn.disabled = true;
      resultsEl.innerHTML = '';
      hostResultsEl.innerHTML = '';
      fastestOriginEl.value = '';

      const datasetUrl = document.getElementById('datasetUrl').value.trim();
      const imageRoot = normalizeRoot(document.getElementById('imageRoot').value);

      if (isAbsoluteHttpUrl(imageRoot)) {
        statusEl.textContent =
          'Find Fastest skipped: imageRoot is an absolute URL, so Origin is not used.\n' +
          'Set imageRoot to a path (e.g. /rosetta/NAC4I.1/J80/) to test origins.';
        runBtn.disabled = false;
        findFastestBtn.disabled = false;
        return;
      }

      const hosts = await fetchCdnHosts();
      if (!hosts) {
        statusEl.textContent = 'Could not load https://comet.photos/cdn_hosts.json — skipping.';
        runBtn.disabled = false;
        findFastestBtn.disabled = false;
        return;
      }

      statusEl.textContent = 'Fetching dataset JSON...';
      const dataset = await fetchDatasetJson(datasetUrl);

      const raceCountRaw = parseInt(raceCountEl?.value, 10);
      const raceCount = Math.max(1, Math.min(50, Number.isFinite(raceCountRaw) ? raceCountRaw : 1));

      // Randomly select ONCE per click (so all hosts fetch the same set).
      const shuffled = dataset.slice();
      shuffleInPlace(shuffled);
      const selected = shuffled.slice(0, Math.min(raceCount, shuffled.length));

      const imgPaths = selected.map(entry => buildNac4iPath(imageRoot, entry));

      const stamp = Date.now();
      statusEl.textContent =
        `Testing ${hosts.length} hosts with ${imgPaths.length} sequential images...\n` +
        `First sample: ${imgPaths[0]}`;

      const timeoutMs = 15000;

      // For each host, sequentially download all selected images. Host is OK only if all succeed.
      const rows = await Promise.all(hosts.map(async (h, i) => {
        let totalMs = 0;
        let totalBytes = 0;

        for (let k = 0; k < imgPaths.length; k++) {
          const p = imgPaths[k];
          const cb = `cb=${stamp}-${i}-${k}-${Math.random().toString(36).slice(2)}`;
          const url = `https://${h}${p}?${cb}`;

          const r = await timedDownload(url, timeoutMs);
          totalMs += r.ms || 0;
          totalBytes += r.bytes || 0;

          if (!r.ok) {
            return { host: h, url: `(failed on #${k + 1}) ${p}`, ok: false, ms: totalMs, bytes: totalBytes, err: r.err || 'error' };
          }
        }

        return { host: h, url: `(all ${imgPaths.length} OK)`, ok: true, ms: totalMs, bytes: totalBytes, err: '' };
      }));

      // Sort: OK first by time, then errors
      rows.sort((a, b) => {
        if (a.ok !== b.ok) return a.ok ? -1 : 1;
        return (a.ms ?? 1e18) - (b.ms ?? 1e18);
      });

      renderHostLines(rows);

      const winner = rows.find(r => r.ok);
      if (winner) {
        const winnerOrigin = `https://${winner.host}`;
        fastestOriginEl.value = winnerOrigin;
        originEl.value = winnerOrigin;
        statusEl.textContent =
          `Fastest: ${winnerOrigin}\n` +
          `Total time: ${winner.ms.toFixed(1)} ms (${winner.bytes} bytes)\n` +
          `Click “Test” next to any OK host to run the full image test against it.`;
      } else {
        statusEl.textContent = 'No hosts succeeded.';
      }

      runBtn.disabled = false;
      findFastestBtn.disabled = false;
    }

    function median(nums) {
      const a = nums.filter(n => Number.isFinite(n)).slice().sort((x, y) => x - y);
      if (a.length === 0) return NaN;
      const mid = Math.floor(a.length / 2);
      return (a.length % 2) ? a[mid] : (a[mid - 1] + a[mid]) / 2;
    }
    function mean(nums) {
      const a = nums.filter(n => Number.isFinite(n));
      if (a.length === 0) return NaN;
      return a.reduce((s, n) => s + n, 0) / a.length;
    }

    async function runTest() {
      runBtn.disabled = true;
      findFastestBtn.disabled = true;
      resultsEl.innerHTML = '';
      statusEl.textContent = 'Fetching dataset JSON...';

      const datasetUrl = document.getElementById('datasetUrl').value.trim();
      const imageRoot = normalizeRoot(document.getElementById('imageRoot').value);
      const origin = normalizeOrigin(originEl.value);
      const imageCount = parseInt(document.getElementById('imageCount').value, 10) || 100;

      const dataset = await fetchDatasetJson(datasetUrl);

      // Shuffle so you don't always hit same months/blocks
      const shuffled = dataset.slice();
      shuffleInPlace(shuffled);

      const selected = shuffled.slice(0, Math.min(imageCount, shuffled.length));
      const urls = selected.map(entry => {
        const path = buildNac4iPath(imageRoot, entry);
        if (isAbsoluteHttpUrl(imageRoot)) return path;
        return joinOriginAndPath(origin, path);
      });

      statusEl.textContent = `Starting sequential download of ${urls.length} images...`;

      let totalBytes = 0;
      const perImage = [];
      const testStart = performance.now();

      for (let i = 0; i < urls.length; i++) {
        const baseUrl = urls[i];
        const cacheBuster = 'cb=' + Date.now() + '-' + i + '-' + Math.random().toString(36).slice(2);
        const url = baseUrl + (baseUrl.includes('?') ? '&' : '?') + cacheBuster;

        const t0 = performance.now();
        let ok = true, errMsg = '', bytes = 0;

        try {
          const resp = await fetch(url, { cache: 'no-store' });
          if (!resp.ok) { ok = false; errMsg = `HTTP ${resp.status}`; }
          else {
            const buf = await resp.arrayBuffer();
            bytes = buf.byteLength;
            totalBytes += bytes;
          }
        } catch (e) {
          ok = false;
          errMsg = e?.message || 'network error';
        }

        const ms = performance.now() - t0;
        const mbits = bytes * 8 / 1e6;
        const mbps = ms > 0 ? mbits / (ms / 1000) : 0;

        perImage.push({ index: i + 1, url: baseUrl, bytes, ms, mbps, ok, errMsg });

        const runningTime = (performance.now() - testStart) / 1000;
        const totalMbits = totalBytes * 8 / 1e6;
        const avgMbps = runningTime > 0 ? totalMbits / runningTime : 0;

        const msAll = perImage.map(r => r.ms);
        const msOk = perImage.filter(r => r.ok).map(r => r.ms);

        statusEl.textContent =
          `Origin: ${isAbsoluteHttpUrl(imageRoot) ? '(imageRoot absolute)' : (origin || '(blank)')}\n` +
          `Fetched ${i + 1} / ${urls.length}\n` +
          `Last: ${ok ? 'OK' : 'ERR'} (${bytes} bytes in ${ms.toFixed(1)} ms, ${mbps.toFixed(2)} Mbps)\n` +
          `Total: ${(totalBytes / (1024 * 1024)).toFixed(3)} MiB\n` +
          `Elapsed: ${runningTime.toFixed(2)} s\n` +
          `Avg throughput: ${avgMbps.toFixed(2)} Mbps\n` +
          `Avg ms/image (all): ${mean(msAll).toFixed(1)} | median: ${median(msAll).toFixed(1)}\n` +
          `Avg ms/image (OK):  ${msOk.length ? mean(msOk).toFixed(1) : 'n/a'} | median: ${msOk.length ? median(msOk).toFixed(1) : 'n/a'}`;
      }

      const totalSeconds = (performance.now() - testStart) / 1000;
      const totalMbits = totalBytes * 8 / 1e6;
      const overallMbps = totalSeconds > 0 ? totalMbits / totalSeconds : 0;

      const msAll = perImage.map(r => r.ms);
      const okRows = perImage.filter(r => r.ok);
      const msOk = okRows.map(r => r.ms);
      const failCount = perImage.length - okRows.length;

      statusEl.textContent +=
        `\n\n=== FINAL ===\n` +
        `Images: ${perImage.length} (OK: ${okRows.length}, ERR: ${failCount})\n` +
        `Bytes: ${totalBytes} (${(totalBytes / (1024 * 1024)).toFixed(3)} MiB)\n` +
        `Time: ${totalSeconds.toFixed(2)} s\n` +
        `Throughput: ${overallMbps.toFixed(2)} Mbps\n` +
        `Avg ms/image (all): ${mean(msAll).toFixed(1)} | median: ${median(msAll).toFixed(1)}\n` +
        `Avg ms/image (OK):  ${msOk.length ? mean(msOk).toFixed(1) : 'n/a'} | median: ${msOk.length ? median(msOk).toFixed(1) : 'n/a'}\n`;

      renderImageTable(perImage);

      runBtn.disabled = false;
      findFastestBtn.disabled = false;
    }

    function renderImageTable(perImage) {
      let html = '<table><thead><tr>' +
        '<th>#</th><th>URL</th><th>Bytes</th><th>Time (ms)</th><th>Mbps</th><th>Status</th>' +
        '</tr></thead><tbody>';

      for (const row of perImage) {
        html += '<tr>' +
          `<td>${row.index}</td>` +
          `<td title="${row.url}">${row.url}</td>` +
          `<td>${row.bytes}</td>` +
          `<td>${row.ms.toFixed(1)}</td>` +
          `<td>${row.mbps.toFixed(2)}</td>` +
          `<td>${row.ok ? 'OK' : ('ERR: ' + row.errMsg)}</td>` +
          '</tr>';
      }
      html += '</tbody></table>';
      resultsEl.innerHTML = html;
    }

    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }
  </script>
</body>
</html>
